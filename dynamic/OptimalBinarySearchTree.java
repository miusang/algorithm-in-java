package cn.ning.algorithm.dynamic;

/**
 * 最优二叉查找树
 *
 * 1. 问题描述
 *        给定一个由n个互异的关键字组成的有序序列K={k1, k2, ..., kn}以及序列K每个关键字被查询的概率P={p1,
 *        p2, ..., pn}，要求构造一颗二叉查找树T，使得查询所有元素的总代价最小。
 *        对于一颗查找树，当查找的元素在树内时，表示查找成功；当不在树内时，表示查找失败。用一个"虚叶子节点"来表
 *    示查找失败的情况，因此需要n+1个虚叶子节点{d0, d1, ..., dn}，对应的概率序列是Q={q0, q1, ..., qn}。其中，
 *    d0表示查找元素小于k1的失败情况，dn表示查找元素大于kn的失败情况，di(0 < i < n)表示查找节点在ki和ki+1之间
 *    时的失败情况。因此有如下公式：
 *                     (p1 + p2 + ... + pn) + (q0 + q1 + ... + qn) = 1
 *
 *
 * 2. 问题求解
 *
 */
public class OptimalBinarySearchTree {
    public static void main(String[] args) {

    }
}
